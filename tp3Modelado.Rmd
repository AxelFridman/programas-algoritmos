---
title: "TP3"
output: html_notebook
---
## Axel Fridman
## L.U : 527/20

Buscamos primero cargar todos los datos.


```{r}
df = read.csv("datos_alquiler.csv", stringsAsFactors = F)

```

Vemos todos los atributos de cada propiedad

```{r}
colnames(df)
```
```{r}
table(df$property_type)

mayor = quantile(df$surface_total, 0.99)
label = "Superficies "
hist(df$surface_total, breaks = 100,  freq = F, xlab = label, xlim = c(0,mayor), main ="")
```
```{r}
variables_Interes = c("price", "rooms", "surface_total", "fondo", "lat", "lon")
labelsInteres = c("Precio", "Habitaciones", "Superficie total", "Fondo", "lat", "lon")
variables_Interes2 = c("property_type", "start_date")
par(mfrow=c(2,4))
breaksVector = c(40,20,50,35,20,20)
plot(df[,variables_Interes[5]], df[,variables_Interes[6]], xlab = "Longitud", ylab = "Latitud")
for (i in 1:length(variables_Interes)) {
  #mayor = quantile(df[,variables_Interes[i]], 1, na.rm=T)
  label = labelsInteres[i]
  hist(df[,variables_Interes[i]], breaks = breaksVector[i],  freq = F, xlab = label, main ="")
}
with(df,{
  
tiposProp = table(property_type)
prop.table(table(tiposProp))
barplot(tiposProp, las=2, cex.names=0.65)
})

```

```{r}
df$start_date = as.Date(df$start_date)
df$diaEsp = factor(weekdays(df$start_date), levels = c("lunes", "martes", "miércoles", "jueves", "viernes","sábado", "domingo"))
df$mesEsp = factor(months(df$start_date), levels= c("enero", "febrero", "marzo", "junio", "julio","agosto", "septiembre", "octubre", "noviembre", "diciembre"))
df$diaIng = factor(weekdays(df$start_date), levels = c("Monday", "Tuesday","Wednesday", "Thursday", "Friday", "Saturday","Sunday"))
df$mesIng = factor(months(df$start_date), levels= c("January", "February", "March","April","May", "June", "July","August", "September", "October", "November", "December"))

with(df,{
par(mfrow=c(1,2))

dias = table(diaEsp) #Poner diaIng o diaEsp segun corresponda
prop.table(table(dias))
barplot(dias, las=2, cex.names=0.65)
meses = table(mesEsp) #Poner mesIng o mesEsp segun corresponda
prop.table(table(meses))
barplot(meses, las=2, cex.names=0.65, )
})
```
```{r}
ajusM1<-lm(price~1,data=df)
coe<-coef(ajusM1)
plot(df$price,  xlab = "Propiedades", ylab = "Precio")
abline(h = coe[1], col='red')
abline(h = quantile(df$price, 0.95), col='blue')
#h = lm(id ~ -1, data=df)
```
Como la linea roja viene de un modelo con un parametro constante que no depende de ninguna variable explicativa es el promedio (con loss function suma de diferencia de cuadrados).
Podemos ver que la mayoria de las propiedades (el 95%) estan concentradas por debajo de la linea azul. Mientras que el 5% de propiedades mas caras empujan el promedio (linea roja) ligeramente arriba del centro de la nube negra de propiedades. 
Es decir el 5% de propiedades mas caras ocupa mas de la mitad del grafico. 


```{r}
with(df,{
par(mfrow=c(1,3))
  
plot(price~surface_covered, xlab ='Superficie cubierta', ylab = 'Precio')
precioSupC<-lm(price~surface_covered,data=df)
coeSP<-coef(precioSupC)
abline(coeSP, col = 'red')

plot(price~fondo, xlab ='Fondo', ylab = 'Precio')
precioFon<-lm(price~fondo,data=df)
coeFP<-coef(precioFon)
abline(coeFP, col = 'red')

plot(price~start_date, xlab ='Fecha de pub', ylab = 'Precio')
precioFecha<-lm(price~start_date,data=df)
coeFech<-coef(precioFecha)
abline(coeFech, col = 'red')
})

```
A los datos me remito, es muchisimo mas clara la relacion entre superficie cubierta y precio, que precio y fondo. 
Ni que hablar fecha de publicacion, en el cual se ve que mi coeficiente de grado 1 es practicamente 0. Con lo cual obtenemos algo similar al promedio de fecha de publicacion. 

```{r}
precioSupC<-lm(price~surface_covered,data=df)
precioFecha<-lm(price~start_date,data=df)
precioFon<-lm(price~fondo,data=df)

summary(precioSupC)
summary(precioFon)
summary(precioFecha)


```
El R de cada modelo esta ordenado como el grafico. Superf cub > fondo > fecha de pub
Notado que de los residuos, el mediano es siempre negativo, puedo deducir que el modelo esta prediciendo que el elemento del medio deberia ser mas grande que el que es. Esto puede deberse a la influencia de lo mucho mayor que es el precio cuando la superficie es mas grande, lo cual podria deberse a que el modelo lineal no se ajusta del todo bien por como estan distribuidos los precios en relacion a la sup.

```{r}
summary(precioSupC$residuals)
summary(precioFon$residuals)
summary(precioFecha$residuals)

#sqrt(sum((precioSupC$residuals)**2))
```
```{r}
plot(df$surface_covered, df$price, col='red', ylim = c(0 , 1.5*max(predict(precioSupC))), xlab = 'Superficie cubierta', ylab = 'Precio')
points( df$surface_covered, predict(precioSupC), col='blue')
```
La prediccion en azul mientras que los datos en rojo. Se puede ver como la 'dispersion' de los precios de superficie mas baja es menor, entonces uno puede tener una mejor prediccion, mientras que si aumenta mucho la superficie la variabilidad del precio es mayor, y el modelo le pifia mas. 


```{r}
desempenioHastaPorcentaje = function(porcentaje){
  sup = quantile(df$surface_covered, porcentaje)
  sups = df[df$surface_covered <= sup,]$surface_covered
  precio = df[df$surface_covered <= sup,]$price
  modelo<-lm(precio~sups,data=df)
  return(summary(lm(precio~sups, data=df))$r.squared)
  
}
```
```{r}
porcentajes = c(1:100)/100
plot(sapply(porcentajes, desempenioHastaPorcentaje), xlab = 'Porcentaje del dataset evaluado en modelo', ylab = 'Error del modelo en R cuadrado')
```
Claramente el error crece raoidamente y "de a saltos" a medida que tomo un mayor porcentaje de los datos.


```{r}
par(mfrow=c(1,3))
plot(precioSupC$residuals, xlab = 'Residuos superficie cubierta', ylab = 'Residuos')
abline(h=0,col= 'red')
plot(precioFon$residuals, xlab = 'Residuos fondo', ylab = 'Residuos')
abline(h=0,col= 'red')
plot(precioFecha$residuals, xlab = 'Residuos fecha de pub', ylab = 'Residuos')
abline(h=0,col= 'red')
```
Tal como esperabamos, el promedio del modulo los residuos es mas chico en superifice cubierta (grafico mas comprimido en 0) mientras que va aumentando debido a mayores diferencias al 0 en los otros graficos. 

```{r}
modeloPrecioTiempo = lm(price~start_date, data = df)
plot(df$price~df$start_date, xlab="Fecha", ylab="Precio")
abline(coef(modeloPrecioTiempo), col='red')
```
No se aprecia la inflacion, es practicamente una constante.

```{r}
modeloPrecioTipoPropiedad = lm(price~property_type, data = df)
boxplot(df$price~df$property_type)
coefProp = coef(modeloPrecioTipoPropiedad)
abline(modeloPrecioTipoPropiedad)
print(coefProp)
```
Lo que este modelo nos dice es que las casas por el simple hecho de ser casas tienen un valor promedio de 22981 (que actua como una 'base' para el resto de las propiedades. 
Mientras que ser un departamento te penaliza por -5852 menos el precio relativo a una casa y ser un PH tambien te penaliza por -3103. 
El modelo que hice solamente conecta precio de Casa vs Departamento

```{r}
lm(price~fondo+property_type+lat+lon+start_date+rooms, data = df)
```

